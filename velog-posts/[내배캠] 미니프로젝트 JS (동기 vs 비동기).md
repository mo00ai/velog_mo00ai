<h3 id="미니프로젝트-진행하면서-배운-점들-정리">미니프로젝트 진행하면서 배운 점들 정리</h3>
<br />
<br />

<p><a href="https://velog.io/@khy226/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0%EB%9E%80-Promise-asyncawait-%EA%B0%9C%EB%85%90">https://velog.io/@khy226/동기-비동기란-Promise-asyncawait-개념</a></p>
<h4 id="동기-vs-비동기">동기 vs 비동기</h4>
<p>우선 차이점부터 설명하자면, 동기는 '직렬적'으로 작동하는 방식이고 비동기는 '병렬적'으로 작동하는 방식이다. 즉, 비동기란 특정 코드가 끝날때 까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 것을 의미한다. 비동기 처리를 예로 Web API, Ajax, setTimeout 등이 있다.</p>
<p>아래 사진을 통해 차이점을 한눈에 볼 수 있다.</p>
<p>왼쪽 차트는 '비동기'로 작동하는 방식이다. 한번에 여러 태스크가 동시에 병렬적으로 실행된다.
반면, 오른쪽 차트는 '동기'적으로 작동하는 방식이다. 하나의 태스크가 끝날 때 까지 기다렸다가 다음 태스크가 실행된다. 총 실행 시간으로 따지자면 '동기' 방식이 더 느리다.
<img alt="" src="https://velog.velcdn.com/images/mo00ai/post/a846d5b3-fd5d-447c-ac24-0b08484d2270/image.png" /></p>
<p>동기(synchronous)'란 무엇일까?
직렬적으로 태스크를 수행하는 방식이다.
즉, 요청을 보낸 후 응답을 받아야지만 다음 동작이 이루어지는 방식이다. 어떠한 태스크를 처리할 동안 나머지 태스크는 대기한다.
실제로 cpu가 느려지는 것은 아니지만 시스템의 전체적인 효율이 저하된다고 할 수 있다.
<img alt="" src="https://velog.velcdn.com/images/mo00ai/post/ffd6aeb7-cbe4-4059-86a7-1338c4d441e0/image.png" /></p>
<p>비동기 (asynchronous)'란 무엇인가?
병렬적으로 태스크를 수행하는 방식이다.
요청을 보낸 후 응답의 수락 여부와는 상관없이 다음 태스크가 동작하는 방식이다. a 태스크가 실행되는 시간 동안 b 태스크를 할 수 있으므로 자원을 효율적으로 사용할 수 있다.
이때, 비동기 요청시 응답 후 처리할 '콜백 함수'를 함께 알려준다. 따라서 해당 태스크가 완료되었을 때, '콜백 함수'가 호출된다.
<img alt="" src="https://velog.velcdn.com/images/mo00ai/post/daa2f79f-4509-4c47-a4b5-237848dbcf5c/image.png" />
하지만 비동기 처리를 위해 콜백 패턴을 사용하면 처리 순서를 보장하기 위해 여러 개의 콜백 함수가 중첩되어 복잡도가 높아지는 콜백 헬(Callback Hell) 이 발생하는 단점이 있다.</p>
<br />

<hr />
<p>콜백함수
-<strong>&quot;다른 함수의 인자로 전달되어 실행되는 함수&quot;</strong>
라 어디에나 쓰일 수 있음 (동기나 비동기나)</p>
<p>그니까 정확하진 않은데 느낌이</p>
<p>함수(콜백함수) {
    //함수 내 코드들
    콜백함수
}</p>
<p>함수에서 콜백함수를 인자를 받으면서 실행함
그래서 함수를 실행하고 콜백함수를 실행함으로서 비동기적으로 처리하는 거임</p>
<p>여기서 나의 의문</p>
<p>그럼 함수 내 코드들이 실행되고 콜백함수도 내가 위치를 지정해서 실행되는거니 동기랑 다를게 뭐가 있냐
-&gt; gpt 답변 : 콜백 실행 순서는 니가 지정하는게 아님! <strong>이벤트 루프 라는 놈이</strong> 동적으로 처리함 지가 알아서
-&gt; 일단 다른 함수들을 처리하고 <strong>비동기 코드들을 나중에 처리한다</strong>
-&gt; 순서가 동기 코드들 -&gt; 비동기 코드라는 소리
    =&gt; 그래서 개발자가 비동기 코드들을 먼저 처리하고 싶을 때 <strong>await</strong>을 씀</p>
<br />
<br />
그래서 등장한게 promise()